// 변수 선언

// 1단계 선언
// 2단게 할당 

// 변수의 할당이란 
// 변수명, 함수명, 등은 식별자이며 식별자안에는 데이터를 저장할 수 있는 메모리 주소를 확보한다. 
// 자바스크립트는 동적 언어이기 때문에 런타임 시점에 할당이 발생하면서 해당 값의 타입을 파악한다. 
// 메모리의 공간을 유한하다.
// 따라서 재할당이 발생할때 기존에 메모리 주소에 새로운 값이 할당되는것이 아닌, 새로운 메모리 주소에 값이 할당되는 형식,
// 기존 메모리 주소를 참조하는 관계가 없을떄 가비지 콜텍터에의해 소멸된다. 

//var 
// 엔진이 소스코드를 런타임 하기 이전 평과 과정에서 실행컨텍스트 레코드에 선언부를 등록하는과정에서 
// var는 선언과 할당이 동시에 진행되면서 undefined로 초기화된다. 
// 따라서 선언문 전에 콘솔을 찍어보아도 에러가 아닌 값이 나오면서 이를 최상단에 끌어올려진듯 하다 해서 호이스팅이라 부른다. 

console.log(`age2`, age2)  //undefined  
var age2 = 10;

//let
// let은 평과과정에서 선언되고 var와 달리 런타임 시기에 코드문을 만날때 할당값이 배정되기 떄문에 호이스팅이 발생하지 않는다. 
// let의 특징 
// 1.  중복 선언이 불가하며, 
// 2. 값의 재할당은 가능하다. 
// console.log(`age1`,age) // 오류 : Cannot access 'age' before initialization  
let age; 
console.log(`age1`,age) // undefined



//const 
// const 평과과정에서 선언되고 var와 달리 런타임 시기에 코드문을 만날때 할당값이 배정되기 떄문에 호이스팅이 발생하지 않는다. 
// 절대로 변하지 않는 상수를 입력할 때 사용 한다. 
// const의 특징 
// 1. 중복 선언이 불가하다. 
// 2. 값의 재할당은 가능하다. 
// 3. 배열의 경우 식별자에 등록된 메모리 주소는 콜스텍이며 실제 데이터는 힙에 저장되기 때문에, 힙에 저장된 데이터의 값이 변경되더라도 콜스텍의 주소는 변하지 않기때문에 
//    const를 사용하여도 값의 변경이 가능하다. 

const age3 =10;
age3 = 15;  //   발생하는 오류 
            // TypeError: Assignment to constant variable.
console.log(age3)


// let과 const를 사용하는 이유 
// 다른 개발자와 협업할때 변수명이 겹치면 값이 덮어씌어지기 때문에 오류가 발생할수 있다. 중복선언이 되지 않는 let,const를 활용해 이를 방지한다.


/*
  tip 
    모든 선언을 const로 한뒤 값의 변경의 여지가 있을 경우에만 let으로 변경한다. 
*/




